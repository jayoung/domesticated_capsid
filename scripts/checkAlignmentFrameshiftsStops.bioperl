#!/usr/bin/perl

use warnings;
use strict;
use Bio::AlignIO;
use Bio::SeqIO;
use Getopt::Long;

##### input is a multiple sequence alignment, with a reference sequence that encodes a complete ORF as the first sequence. 
## default option is to deal with output of MACSE (--MACSE=1), which tries to align in-frame, and frameshifts are denoted by ! characters.
## if --MACSE=0, we expect maf converted to fasta, where alignments are often not in-frame at all (if there are indels in non-ref seqs)

## tests each other sequence for frameshifts w.r.t. the reference sequence, and stop codons that are not at the end of the sequence.
## I do tolerate frameshifts at the very beginning or very end of each aligned seq
## tests the reference seq for an intact ORF
## allows for a special case, PEG10, that has a programmed ribosome frameshift, and allows us to ignore frameshifts within a certain distance of the programmed frameshift
## tolerates stops near but not quite at the end (as well as AFTER end of ref seq) - tolerable distance is (by default) 60bp (20 codons)


## output = four files: 
# noPseuds.fa = same alignment, without any pseudogenes
# pseudReportSummary.txt = num intact genes and pseudogenes
# pseudReportEachGene.txt = which genes are intact/pseuds
# pseudReportDetailed.txt = locations of stop codons/frameshifts in each pseudogene

# checkAlignmentFrameshiftsStops.bioperl PNMA3_NM_013364.refGene.100way.frags.2.combined.fa.degapped


#### one gene has a programmed ribosomal frameshift. MACSE does find it, although it might not be in exactly the right place
our %programmedFrameshiftGenes;
$programmedFrameshiftGenes{'PEG10'} = 1;
# for programmed ribosomal frameshift genes, sometimes the other seq has frameshift in a slightly different place. This specifies the acceptable distance in base-pairs for frameshifts in the other species. If closer than this distance, it is assumed to be the programmed frameshift but in the wrong place 
our $fsDistCheck = 30;


#### defaults for command-line specifiable options:
our $stopCodonDistCheck = 60; ## stop codon is OK if it is within this distance from the end of the reference seq (also OK if any distance after the end of the reference seq)
our $alnIsMACSE = 1; ## 0 or 1, whether the alignment is output of MACSE aligner (so that frameshifts can be encoded by !)
our $minAlignedLengthProportion = 0.8; ## proportion of refseq len that the ungapped length of a a seq needs to cover - if it doesn't meet this threshold, it will be called 'truncated'
our $debug = 0;  ## to help figure things out

###### get any command line options

## get any non-default options from commandline
GetOptions("MACSE=i" => \$alnIsMACSE,
           "minLen=i" => \$minAlignedLengthProportion,
           "stopCodonDist=i" => \$stopCodonDistCheck,
           "debug=i" => \$debug
            ) or die "\n\nterminating - unknown option(s) specified on command line\n\n";


########## script

if ($alnIsMACSE == 1) {
    print "\n\nParsing MACSE alignment - frameshifts should be denoted by ! characters\n\n";
} else {
    print "\n\nParsing non-MACSE alignment\n\n";
}

foreach my $file (@ARGV){
    if (!-e $file) { die "\n\nterminating - cannot open file $file\n\n"; }
    print "\n#### working on file $file\n";
    ## gene should be the first part of the file name
    my $gene = "notDefined";
    if ($file !~ m/_/) {
        print "    cannot figure out gene name from file name $file\n";
    } else {
        $gene = (split /_/, $file)[0];
        print "    gene $gene\n";
    }
    my $outStem = $file; $outStem =~ s/\.fasta$//; $outStem =~ s/\.fa$//;
    my $outSeqs = "$outStem.noPseuds.fa";
    my $outReportEachGene = "$outStem.pseudReportEachGene.txt";
    my $outReportOverallSummary = "$outStem.pseudReportSummary.txt";
    my $outReportDetails = "$outStem.pseudReportDetailed.txt";
    
    my $seqOUT = Bio::SeqIO->new(-file => "> $outSeqs", '-format' => 'fasta');
    open (SUMMARY, "> $outReportOverallSummary");
    print SUMMARY "Gene_type\tCount\tFile\n";
    open (EACHGENE, "> $outReportEachGene");
    print EACHGENE "Seq\tPseud\tNum_frameshifts\tNum_stops\tUngapped_length\n";
    open (DETAILS, "> $outReportDetails");
    print DETAILS "Seq\tRegion_start_refCoord\tRegion_end_refCoord\tRegion_start_alnCoord\tRegion_end_alnCoord\tIndel_size\tRegion_type\n";
    
    my $refSeq = "NA"; my $refName;
    my $lengthThreshold;
    my $refCounts = 0; my $intactCounts = 0; my $pseudCounts = 0; my $truncatedCounts = 0;
    ## the ! in MACSE alignments made validate_seq complain, so I redefined that subroutine below
    my $alnIN = Bio::AlignIO->new(-file => "< $file",
                                 -alphabet => "dna", 
                                 -format => "fasta");
    while (my $aln = $alnIN -> next_aln) {
        if (! $aln->is_flush() ) {
            die "\n\nterminating - seqs in alignment are not all the same length - input file was $file\n\n";
        }
        my $alnLen = $aln->length();
        
        ## use gap_col_matrix to see where the alignment gaps are. Generates an array where each element in the array is a hash reference with a key of the sequence name and a value of 1 if the sequence has a gap at that column
        my $gapsRef;
        if ($alnIsMACSE==1) {
            $gapsRef = $aln->gap_col_matrix("-|!");
        } else {
            $gapsRef = $aln->gap_col_matrix();
        }
        my @gaps = @{$gapsRef};
        
        my @refBases; my @seqBases; my $ungappedRefLen;
        my %refInfo; # keys = status: pseud/intact
                     #        MACSEframeshifts (array of 0-based bp locations w.r.t. ref seq of any MACSE frameshifts (!)
                     #        inFrameStops (array of 0-based bp locations w.r.t. ref seq of any MACSE frameshifts (!)
        ### iterate through each non-ref seq
        ## go through the seqs
        foreach my $seq ( $aln->each_seq() ) {
            
            ### the first sequence is the ref seq
            if ($refSeq eq "NA") {
                $refSeq = $seq;
                $seqOUT->write_seq($seq);
                $refName = $seq->display_id();
                @refBases = split //, $seq->seq();
                $refCounts++;
                $ungappedRefLen = getUngappedLen($refSeq, $alnIsMACSE);
                $lengthThreshold = $ungappedRefLen * $minAlignedLengthProportion;
                my $rounded = sprintf("%.1f", $lengthThreshold);
                print "    got reference seq $refName ungapped length $ungappedRefLen bp : length threshold is $rounded";
                print "\n\n";
                
                ## we check the reference seq for unexpected stops and frameshifts, e.g. for PEG10, which has a programmed frameshift.
                my $numRefFrameshifts = 0; my $numRefStops = 0;
                %refInfo = checkRefSeqIntact($refSeq);
                if ($refInfo{'status'} eq "pseud") {
                    if (defined $refInfo{'MACSEframeshifts'}) {
                        $numRefFrameshifts = @{$refInfo{'MACSEframeshifts'}};
                    }
                    if (defined $refInfo{'inFrameStops'}) {
                        $numRefStops = @{$refInfo{'inFrameStops'}};
                    }
                    print "    WARNING - the reference sequence has frameshifts or in-frame stop codons\n";
                    print "        Num frameshifts $numRefFrameshifts num stops $numRefStops\n";
                    # check whether this is listed as being OK to be pseud
                    if (defined $programmedFrameshiftGenes{$gene}) {
                        print "        BUT it is gene $gene where we expect a programmed frameshift\n";
                    }
                    print "\n";
                }
                
                ## output for ref seq
                print EACHGENE "$refName\tReference\t$numRefFrameshifts\t$numRefStops\t$ungappedRefLen\n";
                next;
            }
            
            ### check remaining seqs against reference seq
            my $seqName = $seq->display_id();
            @seqBases = split //, $seq->seq();
            my $ungappedSeqLen = getUngappedLen($seq, $alnIsMACSE);
            if ($debug==1) { print "    got other seq $seqName ungappedSeqLen $ungappedSeqLen\n"; }
            ### iterate through alignment positions
            my $refPosition = 0; my $seqPosition = 0;
            my $refIsInAGap = ""; my $seqIsInAGap = "";
            my $refCharsWithinThisGapCount = 0; my $seqCharsWithinThisGapCount = 0;
            my $gapOpenPosRef; my $gapOpenPosAln;
            my $numFrameshifts = 0; my $numStops = 0;
            my $refCodon = ""; my $seqCodon = ""; ## these codons will be what's aligned to each codon in the ungapped ref seq
            #  then at each position of the alignment I will compare non-ref to ref, and see if they have the same or opposite gap status.  
            # If it's opposite, in whichever sequence has the 'insertion' relative to the other, I start counting non-gap characters, until the gap ends in the other seq. 
            # Once the gap ends, I total up the non-gap characters, and see if it's a multiple of three.
            for (my $i=0; $i<$alnLen; $i++) {
                my $refGapThisPos = ${$gaps[$i]}{$refName};
                my $seqGapThisPos = ${$gaps[$i]}{$seqName};
                ## for positions where ref is non-gap, update the codons
                if ($seqGapThisPos eq "") { $seqPosition++ ; }
                my $distFromSeqEnd = $ungappedSeqLen - $seqPosition;
                my $distFromRefEnd = $ungappedRefLen - $refPosition;
                
                #### if it is a MACSE alignment, we check for stop codons w.r.t. the in-frame alignment (if not we check below)
                if ($alnIsMACSE==1) {
                    $refCodon .= $refBases[$i];
                    $seqCodon .= $seqBases[$i];
                    ($refCodon, $seqCodon, $numStops) = checkForStopCodon($refCodon, $seqCodon, $refPosition, $distFromRefEnd, $i, $seqName, $numStops);
                }
                
                if ($refGapThisPos eq "") { 
                    #### if it is a non-MACSE alignment, we check for stop codons w.r.t the ungapped ref seq.
                    if ($alnIsMACSE==0) {
                        $refCodon .= $refBases[$i];
                        $seqCodon .= $seqBases[$i];
                        ($refCodon, $seqCodon, $numStops) = checkForStopCodon($refCodon, $seqCodon, $refPosition, $distFromRefEnd, $i, $seqName, $numStops);
                    }
                    $refPosition++;
                }
                
                #### open a gap in the ref seq w.r.t. the other seq
                if (($refIsInAGap eq "") & 
                    ($refGapThisPos eq "1") & 
                    ($refGapThisPos ne $seqGapThisPos)) {
                    if ($debug==1) {
                        print "        pos $i opening a gap in reference seq compared to $seqName\n";
                    }
                    $refIsInAGap = "1"; 
                    $gapOpenPosRef = $refPosition;
                    $gapOpenPosAln = $i + 1;
                }
                #### close a gap in the ref seq w.r.t. the other seq
                if (($refIsInAGap eq "1") & 
                    ($refGapThisPos eq "") & 
                    ($seqGapThisPos eq "")) {
                    if ($debug==1) {
                        print "        pos $i closing a gap in reference seq compared to $seqName\n";
                        print "            $seqName had $seqCharsWithinThisGapCount non-gap chars\n";
                    }
                    if (($seqCharsWithinThisGapCount % 3) != 0) {
                        $numFrameshifts = reportFrameshift($refPosition, $seqPosition, $i, $seqCharsWithinThisGapCount, $distFromSeqEnd, $gapOpenPosRef, $gapOpenPosAln, $numFrameshifts, "insertion", $seqName, $gene, \%refInfo);
                    }
                    $refIsInAGap = "";
                    $refCharsWithinThisGapCount = 0; ## reset
                    $seqCharsWithinThisGapCount = 0; ## reset
                }
                #### continue a gap in the ref seq w.r.t. the other seq
                if (($refIsInAGap eq "1") & 
                    ($refGapThisPos eq "1")) {
                    if ($debug==1) {
                        print "            pos $i continuing a gap in reference seq compared to $seqName\n";
                    }
                    if ($seqGapThisPos eq "") {$seqCharsWithinThisGapCount++;}
                }
                #### open a gap in this seq w.r.t. the ref seq
                if (($seqIsInAGap eq "") & 
                    ($seqGapThisPos eq "1") & 
                    ($refGapThisPos ne $seqGapThisPos)) {
                    if ($debug==1) {
                        print "        pos $i opening a gap in $seqName compared to ref\n";
                    }
                    $seqIsInAGap = "1"; 
                    $gapOpenPosRef = $refPosition; 
                    $gapOpenPosAln = $i + 1;
                }
                #### continue a gap in the ref seq w.r.t. the other seq
                if (($seqIsInAGap eq "1") & 
                    ($seqGapThisPos eq "1")) {
                    if ($debug==1) {
                        print "            pos $i continuing a gap in $seqName compared to ref\n";
                    }
                    if ($refGapThisPos eq "") {$refCharsWithinThisGapCount++;}
                }
                #### close a gap in this seq w.r.t. the ref seq
                if (($seqIsInAGap eq "1") & 
                    ($seqGapThisPos eq "")) {
                    if ($debug==1) {
                        print "        pos $i closing a gap in $seqName compared to ref\n";
                        print "            Ref had $refCharsWithinThisGapCount non-gap chars\n";
                    }
                    if (($refCharsWithinThisGapCount % 3) != 0) {
                        $numFrameshifts = reportFrameshift($refPosition, $seqPosition, $i, $refCharsWithinThisGapCount, $distFromSeqEnd, $gapOpenPosRef, $gapOpenPosAln, $numFrameshifts, "deletion", $seqName, $gene, \%refInfo);
                    }
                    $seqIsInAGap = "";
                    $refCharsWithinThisGapCount = 0; ## reset
                    $seqCharsWithinThisGapCount = 0; ## reset
                }
            } ## end of $i loop (each alignment position)
            print EACHGENE "$seqName\t";
            if ( ($numFrameshifts + $numStops) > 0 ) {
                print EACHGENE "Pseud";
                $pseudCounts++;
            } else {
                ## test Intact genes for whether they're truncated
                if ($ungappedSeqLen < $lengthThreshold) {
                    print EACHGENE "Truncated";
                    $truncatedCounts++;
                } else {
                    print EACHGENE "Intact";
                    $seqOUT->write_seq($seq);
                    $intactCounts++;
                }
            }
            print EACHGENE "\t$numFrameshifts\t$numStops\t$ungappedSeqLen\n";
        } ## end of each seq loop
    } # next_aln loop (meaningless for fasta files, which only contain one alignment
    
    print SUMMARY "Ref\t$refCounts\t$file\n";
    print SUMMARY "Intact\t$intactCounts\t$file\n";
    print SUMMARY "Truncated\t$truncatedCounts\t$file\n";
    print SUMMARY "Pseud\t$pseudCounts\t$file\n";
    
    close EACHGENE;
    close DETAILS;
    close SUMMARY;
} # each input file loop

############# subroutines

sub getUngappedLen {
    my $seqObj = $_[0];
    my $alnIsMACSE = $_[1];
    my $seq = $seqObj->seq();
    $seq =~ s/\-//g;
    if ($alnIsMACSE == 1) { $seq =~ s/\!//g; }
    my $ungappedLen = length($seq);
    return($ungappedLen);
}


### my version of validate_seq, to avoid issues caused by the ! characters
{ no warnings 'redefine';
    sub Bio::LocatableSeq::validate_seq {
        my ($self,$seqstr) = @_;
        if( ! defined $seqstr ){ $seqstr = $self->seq(); }
        return 0 unless( defined $seqstr);
        my $MATCHPATTERN = 'A-Za-z\-\.\*\?=~\!';
        if ((CORE::length($seqstr) > 0) &&
            ($seqstr !~ /^([$MATCHPATTERN]+)$/)) {
            $self->warn("JY seq doesn't validate, mismatch is " .
                    ($seqstr =~ /([^$MATCHPATTERN]+)/g));
                return 0;
        }
        return 1;
     }
}

## simply check an ungapped seq for whether it is an intact ORF. This is only intended for the reference sequence - all the others get checked in a different way. I leave the frameshifts where they are for this purpose.
sub checkRefSeqIntact {
    my $seq = $_[0];
    my $letters = $seq->seq();
    my @eachLetter = split //, $letters;
    my %info;
    $info{'status'} = "intact";
    my $goodORF = 1;
    my $ungapped = $letters; $ungapped =~ s/-//g; 
    if ($ungapped =~ m/\!/) {
        $info{'status'} = "pseud";
        @{$info{'MACSEframeshifts'}} = ();
        my @ungappedLetters = split //, $ungapped;
        my $gappedCount = 0; my $ungappedCount = 0;
        foreach my $l (@eachLetter) {
            if ($l eq "!") {
                push @{$info{'MACSEframeshifts'}}, $ungappedCount;
                my $tempUngappedCount = 1+$ungappedCount;
                my $tempGappedCount = 1+$gappedCount;
                print DETAILS $seq->display_id();
                print DETAILS "\t$tempUngappedCount\t$tempUngappedCount\t";
                print DETAILS "$tempGappedCount\t$tempGappedCount\t";
                print DETAILS "1\tFrameshift ref\n";
            }
            $gappedCount++;
            if ($l !~ m/!|-/) {$ungappedCount++;}
        }
    }
    $ungapped =~ s/!/-/g;
    my $ungappedObj = Bio::Seq->new(-seq=>$ungapped);
    my $translated = $ungappedObj->translate()->seq();
    # stop codon is OK at the end but nowhere else 
    $translated =~ s/\*$//;
    if ($translated =~ m/\*/) {
        $info{'status'} = "pseud";
        my @ungappedAminoAcids = split //, $translated;
        my $gappedCount = 0; my $ungappedCount = 0;
        @{$info{'inFrameStops'}} = ();
        foreach my $u (@ungappedAminoAcids) {
            if ($u eq "*") {
                my $pos = $ungappedCount*3;
                push @{$info{'inFrameStops'}}, $pos;
                $pos = $pos + 1;
                print DETAILS $seq->display_id();
                print DETAILS "\t$pos\t$pos\t";
                print DETAILS "NA\tNA\t";
                print DETAILS "1\tStop codon ref\n";
            }
            $ungappedCount++;
        }
    }
    return(%info);
}

sub checkForStopCodon {
    my ($refCodon, $seqCodon, $refPosition, $distFromRefEnd, $i, $seqName, $numStops) = @_;
    ## if refCodon length is 3, test for stop codons and reset 
    if (length($refCodon)==3) {
        if (uc($refCodon) !~ m/TAA|TAG|TGA/) {
            if (uc($seqCodon) =~ m/TAA|TAG|TGA/) {
                if ($debug==1) {
                    print "        seq $seqName pos $i IN-FRAME STOP CODON!\n";  
                }
                my $stopType = "Stop codon";
                if ($distFromRefEnd < $stopCodonDistCheck) {
                    $stopType = "Ignoring stop codon near end";
                    if ($debug==1) {
                        print "        $seqName has stop codon close to ref end - ignoring\n";
                    }
                } else  {
                    $numStops++;
                }
                print DETAILS "$seqName\t";
                print DETAILS $refPosition-1, "\t", $refPosition+1, "\t";
                print DETAILS $i-1, "\t", $i+1 ;
                print DETAILS "\tNA\t$stopType\n";
            }
        }
        $refCodon = ""; $seqCodon = ""; 
    }
    return ($refCodon, $seqCodon, $numStops);
}

sub reportFrameshift {
    my ($refPosition, $seqPosition, $i, $gapLen, $distFromSeqEnd, $gapOpenPosRef, $gapOpenPosAln, $numFrameshifts, $fsType, $seqName, $gene, $refInfoRef) = @_;
    my %refInfo = %$refInfoRef;
    
    if ($debug==1) {
        print "                FRAMESHIFT! refPosition $refPosition seqPosition $seqPosition distFromSeqEnd $distFromSeqEnd\n";
    }
    if (($seqPosition > 3) & ($distFromSeqEnd > 3)) {
        my $frameshiftIsOK = 0;
        ## if it's PEG10 (etc), we ignore frameshifts
        if (defined $programmedFrameshiftGenes{$gene} ) {
            if (defined $refInfo{'MACSEframeshifts'}) {
                foreach my $fs (@{$refInfo{'MACSEframeshifts'}}) {
                    my $dist = abs( $fs - $refPosition );
                    if ($dist < $fsDistCheck) {
                        $frameshiftIsOK = 1;
                        if ($debug==1) {
                            print "                close enough to programmed frameshift\n";
                        }
                    }
                }
            }
        }
        my $fsTag = "Frameshift $fsType";
        if ($frameshiftIsOK == 0) {
            $numFrameshifts++;
        } else {
            $fsTag = "Possible programmed frameshift";
        }
        print DETAILS "$seqName\t";
        print DETAILS "$gapOpenPosRef\t", $refPosition-1, "\t";
        print DETAILS "$gapOpenPosAln\t", $i ;
        print DETAILS "\t$gapLen\t$fsTag\n";
    }
    return($numFrameshifts);
}
